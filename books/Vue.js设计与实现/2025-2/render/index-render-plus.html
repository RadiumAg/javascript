<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <div id="app"></div>
  </body>

  <script src="https://unpkg.com/@vue/reactivity@3.0.5/dist/reactivity.global.js"></script>
  <script type="module">
    import { createRenderer } from './render-plus.js';
    const { effect, ref } = VueReactivity;
    const bol = ref(false);

    function shouldSetAsProps(el, key, value) {
      // 特殊处理
      if (key === 'form' && el.tagName === 'INPUT') return false;

      // 兜底
      return key in el;
    }

    const renderer = createRenderer({
      createElement(tag) {
        return document.createElement(tag);
      },

      setElementText(el, text) {
        el.textContent = text;
      },

      // 用于在给定的 parent 下添加指定元素
      insert(el, parent, anchor = null) {
        // eslint-disable-next-line unicorn/prefer-modern-dom-apis
        parent.insertBefore(el, anchor);
      },

      patchProps(el, key, prevValue, nextValue) {
        // 匹配 on 开头的属性，视其为事件
        // eslint-disable-next-line unicorn/prefer-string-starts-ends-with
        if (/^on/.test(key)) {
          if (el._vei == null) {
            el._vei = {};
          }
          const invokers = el._vei;
          // 根据属性名称得到对应的事件名称，例如 onClick ----> click
          let invoker = invokers[key];
          const name = key.slice(2).toLowerCase();

          if (nextValue) {
            // eslint-disable-next-line unicorn/no-lonely-if
            if (!invoker) {
              // 如果没有 invoker，则将一个伪造的 invoker 缓存到 ell.vei 中
              // vei 是 vue event invoker 的首字母缩写
              invoker = el._vei[key] = (e) => {
                // 当伪造的事件处理函数执行时，会执行真正的事件处理函数
                invoker.value(e);
                if (Array.isArray(invoker.value)) {
                  invoker.value.forEach((fn) => fn(e));
                } else {
                  invoker.value(e);
                }
              };
              // 将真正的事件处理函数赋值给 invoker.value
              invoker.value = nextValue;
              // 绑定 invoker 作为时间处理函数
              console.count(el.tagName, 'count');
              el.addEventListener(name, invoker);
            } else {
              // 如果 invoker 存在，意味着更新，并且只需要更新 invoker.value的值即可
              invoker.value = nextValue;
            }
          } else if (invoker) {
            // 新的事件绑定函数不存在，且之前绑定的 invoker 存在， 则移除绑定
            el.removeEventListener(name, invoker);
          }
        } else if (key === 'class') {
          el.className = nextValue || '';
        }
        // 使用 shouldSetAsProps 函数判断是否应该作为 DOM Properties 设置
        else if (shouldSetAsProps(el, key, nextValue)) {
          const type = typeof el[key];
          // 如果是布尔类型，并且 value 是空字符串，则将值矫正为 true
          if (type === 'boolean' && nextValue === '') {
            el[key] = true;
          } else {
            el[key] = nextValue;
          }
        } else {
          // 调用 setAttribbute 将属性设置到元素上
          el.setAttribute(key, nextValue);
        }
      },
    });

    effect(() => {
      renderer.render(
        {
          type: 'h1',
          props: bol.value
            ? {
                onClick: () => {
                  alert('父元素 clicked');
                },
              }
            : {},
          children: [
            {
              type: 'p',
              children: 'hello',
              props: {
                onClick: () => {
                  console.log('点击p节点');
                  bol.value = true;
                },
              },
            },
          ],
        },
        document.querySelector('#app')
      );
    });
  </script>
</html>
